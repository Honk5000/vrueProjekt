//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.34209
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using CSharpSynth;
using CSharpSynth.Sequencer;
using CSharpSynth.Synthesis;
using UnityEngine;
using System.Collections.Generic;
public class OrchestraMidiPlayer : MonoBehaviour
{
	public string bankFilePath = "SFZ Bank/sfz";
	private bool _readyToPlay = false;
	public bool readyToPlay {
		get {return _readyToPlay; }
	}
	private OrchestraSong _song;
	public OrchestraSong song {
		get {
			return _song;
		}

	}
	public InstrumentManager instrumentManager;

	private StreamSynthesizer synth = new StreamSynthesizer (StreamSynthesizer.SampleRateType.High);
	private MidiSequencer midiSequencer;

	private float _globalVolume = 1.0f;
	public float globalVolume {
		get {
			return _globalVolume;
		}
		set {
			if (value >= 0.0f && value <= 1.0f) _globalVolume = value;
		}
	}
	private float[] sampleBuffer;

	private bool _isPlaying = false;
	public bool isPlaying {
		get {
			return _isPlaying;
		}
	}
	void Awake ()
	{
		synth.LoadBank (bankFilePath);
		synth.channelProgramOverrides = new Dictionary<int, int>() {{0,1}, {1,1}, {2,81}, {3,57}, {4,82}, {5,41}, {6,58}, {7,25}, {8,1}, {9,26}, {10,82}, {11,22}, {12,81}, {13,81}, {14,2}, {15,3}};

	}

	public void LoadSong(OrchestraSong song) {
		synth.NoteOffAll (true); //stop playing if we were already playing a song
		sampleBuffer = new float[4096];
		midiSequencer = new MidiSequencer (synth);
		midiSequencer.LoadMidi (song.midiFilename, false);
		_readyToPlay = true;
		_song = song;
	}
	public void Play() {
		if (!_readyToPlay) {
			throw new InvalidOperationException("OrchestraMidiPlayer: No song loaded yet. You need to load a song using LoadSong first before calling other methods.");
			return;
		}
		_isPlaying = true;
		midiSequencer.Play ();

	}
	public void Pause() {
		_isPlaying = false;

	}
	public void muteInstrument(InstrumentType type) {
		if (this.song == null)
			return;
		int[] associatedChannels = song.instrumentToChannelNumbersMap [type];
		foreach (int channel in associatedChannels) {
			midiSequencer.MuteChannel(channel);
		}
	}
	public void setPitchBendForInstrument(InstrumentType type, float semitoneDifference) {
		if (this.song == null)
			return;
		int[] associatedChannels = song.instrumentToChannelNumbersMap [type];
		foreach (int channel in associatedChannels) {
			synth.setPitchBend(channel, semitoneDifference);
		}
	}
	public float getPitchBendForInstrument(InstrumentType type) {
		if (this.song == null)
			return 0;
		int[] associatedChannels = song.instrumentToChannelNumbersMap [type];
		if (associatedChannels.Length > 0) {
			return synth.getPitchBend (associatedChannels [0]);
		} else
			return 0;
	}
	public void setVolumeForInstrument(InstrumentType type, float value) {
		if (this.song == null)
			return;
		int[] associatedChannels = song.instrumentToChannelNumbersMap [type];
		foreach (int channel in associatedChannels) {
			synth.setVolume(channel, value);
		}
	}
	public void volumeForInstrument(InstrumentType type) {
	
	}
	public void muteAll() {
		if (this.song == null)
			return;
		midiSequencer.MuteAllChannels();
	}
	public void unmuteInstrument(InstrumentType type) {
		if (this.song == null)
			return;
		int[] associatedChannels = song.instrumentToChannelNumbersMap [type];
		foreach (int channel in associatedChannels) {
			midiSequencer.UnMuteChannel(channel);
		}
	}
	private void Mix(float[] data, int channels)
	{
		int sample = data.Length / channels;

		try {
			synth.GetNext(sampleBuffer, sample);
		}
		catch (System.NullReferenceException e)  {
			// Couldn't call GET NEXT
			//if (e is O 
			System.NullReferenceException ex = e;
			//synth.GetNext(sampleBuffer, sample);
			Debug.Log ("GETNEXT: " + e.Message +" : " + e.Source);
		}
		for (int i = 0; i < sample; i++)
		{
			float b = sampleBuffer[i] * _globalVolume;
			for (int c = 0; c < channels; c++)
			{
				float a = data[i * channels + c];
				data[i * channels + c] = a + b - a * b;
			}
		} 
		float[] realout = new float[data.Length];
		float[] imagout = new float[data.Length];
		
		//Ernzo.DSP.FFT.Compute((uint)data.Length, data, null, realout, imagout, false);
	}
	class LockObj { }
	LockObj _lock = new LockObj();
	private void OnAudioFilterRead(float[] data, int channels)
	{
		/*try
		{*/
		if (_isPlaying) {
			//try  {
				lock (_lock) {
					// mix new audio data and write it to the data stream
					Mix(data, channels);
				}
				
			//}

		} else {
			// currently paused, do nothing
		}

		/*}
		catch (System.Exception e)
		{
			System.Exception ex = e;
			Debug.Log ("ONAUDIOFILTERREAD: " + e.Message +" : " + e.Source);
		}
		*/
	}

}
